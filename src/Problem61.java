import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Problem61 {
	
	/*
	 Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle P3,n=n(n+1)/2 1, 3, 6, 10, 15, ...
Square P4,n=n^2 1, 4, 9, 16, 25, ...
Pentagonal P5,n=n(3n-1)/2 1, 5, 12, 22, 35, ...
Hexagonal P6,n=n(2-1) 1, 6, 15, 28, 45, ...
Heptagonal P7,n=n(5n-3)/2 1, 7, 18, 34, 55, ...
Octagonal P8,n=n(3n-2) 1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
	 */
	
	static int startPoly = 3, endPoly = 8;
	static int totalPolyCount = (endPoly - startPoly) + 1;
	static int triFirst = 0, triLast = 0;
	static int squareFirst = 0, squareLast = 0;
	static int pentFirst = 0, pentLast = 0;
	static int hexFirst = 0, hexLast = 0;
	static int hepFirst = 0, hepLast = 0;
	static int octFirst = 0, octLast = 0;
	
	static Map<Integer, Integer[]> allFirstAndLastIndexes;
	static Map<Integer, List<Integer>> allPolygonalNumbers;
	static Map<Integer, Integer> finalResult;
	static Map<Integer, Boolean> track;
	public static void main(String[] args) {
		allFirstAndLastIndexes = getFirstAndLastIndexes();
		allPolygonalNumbers = getAll4DigitPolygonalNumbers();
		finalResult = new HashMap<Integer, Integer>(); // SHOULD WE KEEP THE ORDER?
		track = getEmptyTracking();//new HashMap<Integer, Boolean>();// use to keep track of what ones we have done ( put 5 true means we found a pentagonal num..
		
		
			problem();
	}

	private static void problem() {
		//start finding triangle numbers that are 4 digits....
		// as we get one... we get the last 2 digits and use those as the first 2 digits for a second number
		// we then go through all 100 other 4 digit numbers that start with those first 2 digits, checking along the way if they are sqaure, pentagonal, hexagonal, heptagonal, or octagonal
		// if we find one of the above.. we then use the last 2 digits of that number to go through the other 100 possible nums and check if they are other polygonal numbers, 
		//until we find one that goes all the way through all polygonal (triangle through octogonal)
		// and make sure the last one is cyclic with the first one...
		
		
		
		
		for(int i=startPoly; i<=endPoly; i++) {
			Integer[] fl = allFirstAndLastIndexes.get(i);
			
			int f = getAPolygonalNumber(i, fl[0]);
			int l = getAPolygonalNumber(i, fl[1]);
			System.out.println("First and last index for " + i + " :: " + fl[0] + ", " + fl[1] + " and those nums are " + f + ", " + l);			
		}
		
		int startingPolygonalNumType = 3;
		
		List<Integer> triNums = allPolygonalNumbers.get(startingPolygonalNumType);
		
		
		
		for(Integer num : triNums) {
			
			List<Integer> numsSoFar = new ArrayList<Integer>();
			
			finalResult.put(startingPolygonalNumType, num);
			
			track.put(startingPolygonalNumType, true); // this doesnt put duplicate entries right? Like 3, true - we cant put another 3, true right?
			
			numsSoFar.add(num);
			
			findPolyNumThatStartsWith(num, numsSoFar);
		}
		
	}
	
	public static void /*List<Integer>*/ findPolyNumThatStartsWith(int num, List<Integer> polyNumsSoFar) {
		
		boolean isDone = false;
		
		//int res = isTrackingComplete();
		
		if(isTrackingComplete()) {
			//all are found....
			if(polyNumsSoFar.size() == totalPolyCount) {
				
				if(getLast2Digits(polyNumsSoFar.get(totalPolyCount-1)).equals(getFirst2Digits(polyNumsSoFar.get(0)))) {
					System.out.println("I think we have a winner !");
					
					int sum = 0;
					for(Integer p : polyNumsSoFar) {
						sum += p;
						System.out.println("winning num: " + p);
					}
					System.out.println("winning SUM: " + sum);
					return; //polyNumsSoFar;
				}
			} else {
				System.out.println("Error! evalresults says nothing is left (all are true) but polynums size is not " + totalPolyCount + ", its " + polyNumsSoFar.size());
				doDiagnostics(polyNumsSoFar);
				System.exit(0);
				return; //polyNumsSoFar;
			}
		}
		
		
		for(int i=startPoly; i<=endPoly; i++) {
			
			if(track.get(i)) {
				continue;
			}
			
			List<Integer> polyNums = allPolygonalNumbers.get(i);
			for(Integer polyNum : polyNums) {
				if(getLast2Digits(num).equals(getFirst2Digits(polyNum))) {
					track.put(i, true);
					
					List<Integer> copyOfPn = copyListInteger(polyNumsSoFar);
					copyOfPn.add(polyNum);
					findPolyNumThatStartsWith(polyNum, copyOfPn); /// maybe can do this with a while loop instead of recur?
				}
			}
			
			
			track.put(i, false); 
			
		}
		
		return; 
		
	}
	
	public static List<Integer> copyListInteger(List<Integer> li){
		List<Integer> ret = new ArrayList<Integer>();
		for(Integer i : li) {
			ret.add(i);
		}
		return ret;
	}
	
	
	public static boolean isTrackingComplete() {
		for(Integer i : track.keySet()) {
			if(!track.get(i)) {
				return false;
			}
		}
		return true;
	}
	
	public static Map<Integer, Boolean> getEmptyTracking() {
		
		
		Map<Integer, Boolean> ret = new HashMap<Integer, Boolean>();
		
		for(int i=startPoly; i<=endPoly; i++) {
			ret.put(i, false);
		}
		
		return ret;
		
	}
	
	public static void doDiagnostics(List<Integer> p) {
		System.out.println("polynums size: " + p.size());
		for(Integer i : track.keySet()) {
			System.out.println("Tracking : " + i  + " is set to " + track.get(i));
		}
		
		
		
	}
	
	public static int getAPolygonalNumber(int which, int ind) {
		
		int num = 0;
		
		
		switch (which) {
		case 3:
			num = Util.getNthTriangleNumber(ind);
			break;
			
		case 4:
			num = Util.getNthSquareNumber(ind);
			break;
			
		case 5:
			num = Util.getNthPentagonalNumber(ind);
			break;
			
		case 6:
			num = Util.getNthHexagonalNumber(ind);
			break;
			
		case 7:
			num = Util.getNthHeptagonalNumber(ind);
			break;
			
		case 8:
			num = Util.getNthOctagonalNumber(ind);
			break;
			
		default:
			break;
		}
		
		return num;
	}
	

	
	
	public static Map<Integer, List<Integer>>getAll4DigitPolygonalNumbers(){
		
		Map<Integer, List<Integer>> all = new HashMap<Integer, List<Integer>>();
		
		for(int i=3; i<=8; i++) {
			List<Integer> nums = new ArrayList<Integer>();
			
			Integer[] indexes = allFirstAndLastIndexes.get(i);
			int firstIndex = indexes[0];
			int lastIndex = indexes[1];
			for(int j=firstIndex; j<=lastIndex; j++) {
				nums.add(getAPolygonalNumber(i,j));
			}
			all.put(i, nums);
		}

		return all;
	}
	

	
	
	public static int get4DigitSquareNumberThatStartsWith(int start) {
		//int first4dSquareIndex = fDetails[1];
		for(int i = squareFirst; i <= squareLast; i++) {
			int s = Util.getNthSquareNumber(i);
			if(getFirst2Digits(s).equals(getLast2Digits(start))){
				return s;
			}
		}
		
		return 0;
	}

	
	public static String getLast2Digits(int n) {
		String ns = n+"";
		if(ns.length() < 2) {
			return "";
		}
		String ret = ns.charAt(ns.length()-2) + "" + ns.charAt(ns.length()-1);
		return ret;
	}
	
	public static String getFirst2Digits(int n) {
		String ns = n+"";
		if(ns.length() < 2) {
			return "";
		}
		String ret = ns.charAt(0) + "" + ns.charAt(1);
		return ret;
	}
	


	
	public static Map<Integer, Integer[]> getFirstAndLastIndexes() {
		Map<Integer, Integer[]> n = new HashMap<Integer, Integer[]>();
		int pNum = 0;
		for(int i=3; i<=8; i++) {
			
			pNum = 0;
			int firstIndex = 0;
			while (!isFourDigits(pNum)) {
				firstIndex++;
				pNum = getAPolygonalNumber(i, firstIndex);
			}
			
			pNum = 0;
			int lastIndex = 0;
			while (!isFiveDigits(pNum)) {
				lastIndex++;
				pNum = getAPolygonalNumber(i, lastIndex);
			}
			lastIndex--;
			
			n.put(i, new Integer[] { firstIndex, lastIndex });
		}
		
		return n;

		
	}
	
	
	public static boolean isFourDigits(int n) {
		String ns = "" + n;
		return ns.length() == 4;
	}
	
	public static boolean isFiveDigits(int n) {
		String ns = "" + n;
		return ns.length() == 5;
	}
	
}
